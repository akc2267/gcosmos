From 4839bdde54cc813cb9560da5624d7126cc6de14c Mon Sep 17 00:00:00 2001
From: Mark Rushakoff <mark@strange.love>
Date: Mon, 29 Jul 2024 11:57:21 -0400
Subject: [PATCH 4/6] feat: add (AppManager[T]).SimulateWithState

I think we can use simulation to determine whether an incoming
transaction is acceptable, but if we had any prior transactions, they
all need to build upon previous state; the app manager did not have a
SimulateWithState method already, so we add it here.
---
 server/v2/appmanager/appmanager.go | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/server/v2/appmanager/appmanager.go b/server/v2/appmanager/appmanager.go
index af54936ebf..674f26d15c 100644
--- a/server/v2/appmanager/appmanager.go
+++ b/server/v2/appmanager/appmanager.go
@@ -49,6 +49,11 @@ type AppManager[T transaction.Tx] interface {
 	// independently of the db state. For example, it can be used to process a query with temporary
 	// and uncommitted state
 	QueryWithState(ctx context.Context, state corestore.ReaderMap, request transaction.Msg) (transaction.Msg, error)
+
+	// SimulateWithState acts like Simulate, but with an initial state passed in
+	// instead of loaded implicitly from the store.
+	// (This is a patch for gcosmos.)
+	SimulateWithState(ctx context.Context, state corestore.ReaderMap, tx T) (server.TxResult, corestore.WriterMap)
 }
 
 // Store defines the underlying storage behavior needed by AppManager.
@@ -219,3 +224,12 @@ func (a appManager[T]) Query(ctx context.Context, version uint64, request transa
 func (a appManager[T]) QueryWithState(ctx context.Context, state corestore.ReaderMap, request transaction.Msg) (transaction.Msg, error) {
 	return a.stf.Query(ctx, state, a.config.QueryGasLimit, request)
 }
+
+// SimulateWithState has been added in as a patch, for gcosmos.
+func (a appManager[T]) SimulateWithState(
+	ctx context.Context,
+	state corestore.ReaderMap,
+	tx T,
+) (server.TxResult, corestore.WriterMap) {
+	return a.stf.Simulate(ctx, state, a.config.SimulationGasLimit, tx)
+}
-- 
2.44.0

